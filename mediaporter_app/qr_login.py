from __future__ import annotations

import http.cookiejar
import json
import urllib.parse
import urllib.request
from pathlib import Path

QR_GENERATE_API = "https://passport.bilibili.com/x/passport-login/web/qrcode/generate"
QR_POLL_API = "https://passport.bilibili.com/x/passport-login/web/qrcode/poll"
NAV_API = "https://api.bilibili.com/x/web-interface/nav"
DEFAULT_UA = (
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
    "AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36"
)


class QrLoginError(RuntimeError):
    pass


class BilibiliQrLoginClient:
    def __init__(self, cookie_output_dir: Path) -> None:
        self.cookie_output_dir = cookie_output_dir
        self.cookie_output_dir.mkdir(parents=True, exist_ok=True)
        self.cookie_jar = http.cookiejar.CookieJar()
        self.opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(self.cookie_jar))

    def generate_qr(self) -> tuple[str, str]:
        payload = self._request_json(QR_GENERATE_API)
        data = payload.get("data") or {}
        qr_url = data.get("url")
        qr_key = data.get("qrcode_key")
        if not isinstance(qr_url, str) or not isinstance(qr_key, str):
            raise QrLoginError(f"Invalid QR payload: {payload}")
        return qr_url, qr_key

    def poll(self, qr_key: str) -> tuple[str, str, str | None]:
        query = urllib.parse.urlencode({"qrcode_key": qr_key})
        payload = self._request_json(f"{QR_POLL_API}?{query}")
        data = payload.get("data") or {}
        status_code = int(data.get("code", -1))
        message = str(data.get("message") or payload.get("message") or "")
        confirm_url = data.get("url")

        if status_code == 0 and isinstance(confirm_url, str):
            return "success", "Login confirmed", confirm_url
        if status_code == 86101:
            return "waiting_scan", "Waiting for QR scan", None
        if status_code == 86090:
            return "waiting_confirm", "Scanned, waiting for confirmation", None
        if status_code == 86038:
            return "expired", "QR code expired", None
        return "error", f"Login failed: {message} (code={status_code})", None

    def finalize_login(self, confirm_url: str) -> tuple[Path, str]:
        self._request_text(confirm_url)
        nav = self._request_json(NAV_API)
        report = self._build_login_report(nav)

        cookie_path = self.cookie_output_dir / "bilibili_qr_login.cookies.txt"
        _save_netscape_cookie_file(self.cookie_jar, cookie_path)
        return cookie_path, report

    def _request_json(self, url: str) -> dict:
        text = self._request_text(url)
        payload = json.loads(text)
        if int(payload.get("code", 0)) not in (0,):
            message = payload.get("message") or payload.get("msg") or "Unknown API error"
            raise QrLoginError(f"{message} (code={payload.get('code')})")
        return payload

    def _request_text(self, url: str) -> str:
        req = urllib.request.Request(url, headers={"User-Agent": DEFAULT_UA, "Referer": "https://www.bilibili.com/"})
        try:
            with self.opener.open(req, timeout=15) as response:
                return response.read().decode("utf-8", errors="ignore")
        except Exception as exc:  # pragma: no cover - network-specific
            raise QrLoginError(str(exc)) from exc

    @staticmethod
    def _build_login_report(payload: dict) -> str:
        data = payload.get("data") or {}
        is_login = bool(data.get("isLogin"))
        uname = str(data.get("uname") or "-")
        mid = str(data.get("mid") or "-")
        vip_type = int(data.get("vipType") or 0)
        vip_status = int(data.get("vipStatus") or 0)
        vip_active = vip_type > 0 and vip_status == 1
        lines = [
            f"isLogin: {is_login}",
            f"username: {uname}",
            f"mid: {mid}",
            f"vipType: {vip_type}, vipStatus: {vip_status}",
            f"VIP active: {vip_active}",
        ]
        return "\n".join(lines)


def _save_netscape_cookie_file(cookie_jar: http.cookiejar.CookieJar, target: Path) -> None:
    with target.open("w", encoding="utf-8", newline="\n") as fp:
        fp.write("# Netscape HTTP Cookie File\n")
        fp.write("# This file is generated by MediaPorter.\n")
        fp.write("\n")
        for cookie in cookie_jar:
            if "bilibili.com" not in cookie.domain:
                continue
            domain = cookie.domain
            include_subdomains = "TRUE" if domain.startswith(".") else "FALSE"
            path = cookie.path or "/"
            secure = "TRUE" if cookie.secure else "FALSE"
            expires = str(int(cookie.expires or 0))
            name = cookie.name
            value = cookie.value
            fp.write(
                "\t".join([domain, include_subdomains, path, secure, expires, name, value])
            )
            fp.write("\n")
